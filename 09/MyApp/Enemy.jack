class Enemy {

  field int x, y, dx, dy;
  field int length;
  field int direction;
  field int randDirectionSeed;
  field int relativeMemAddress;
  field boolean outOfBounds;
  field int memAddress;
  field int wall; //1 = top, 2 = right, 3 = bottom, 4 = left

  /** Constructs a new Enemy object. */
  constructor Enemy new(int in_x, int in_y) {
    let length = 16;
    let x = in_x;
    let y = in_y;

    let dx = 10;
    let dy = 10;

    let randDirectionSeed = Memory.alloc(1);
    do setDirection(Enemy.modulus(randDirectionSeed, 5));

    return this;
  }

  /** Deallocates the object's memory. */
  method void dispose() {
    do Memory.deAlloc(this);
    return;
  }

  /** Shows the enemy. */
  method void show(int relativeMemAddress) {
    do Screen.setColor(true);
    do draw(relativeMemAddress);
    return;
  }

  /** Hides the enemy. */
  method void hide(int relativeMemAddress) {
    do Screen.setColor(false);
    do refreshFrame(relativeMemAddress);
    return;
  }

  /** Sets the direction the enemy is traveling */
  method void setDirection(int in_direction) {
    let direction = in_direction;

    return;
  }

  /** Returns the direction of the enemy object it is called on */
  method char getDirection() {
    return direction;
  }

  method void move() {
    let outOfBounds = false;

    let relativeMemAddress = (32 * y) + (x / 16);
    let outOfBounds = checkIfOutOfBounds(x, y);
    if (~outOfBounds) {
      do hide(relativeMemAddress);
    }

    if(direction = 1) { //down-left
      let x = x - dx;
      let y = y + dy;
    } else {
      if(direction = 2) { //down-right
          let x = x + dx;
          let y = y + dy;
      } else {
        if(direction = 3) { //up-right
            let x = x + dx;
            let y = y - dy;
        } else {
          if(direction = 4) { //up-left
              let x = x - dx;
              let y = y - dy;
          }
        }
      }
    }

    do Output.moveCursor(2,8);
    do Output.printInt(x);
    do Output.moveCursor(3,8);
    do Output.printInt(y);

    let outOfBounds = checkIfOutOfBounds(x, y);
    if (~outOfBounds) {
      do Screen.setColor(true);
      let relativeMemAddress = (32 * y) + (x / 16);
      do show(relativeMemAddress);
    } else {
      let randDirectionSeed = Memory.alloc(1);
      do Output.moveCursor(1,8);
      do Output.printInt(Enemy.modulus(randDirectionSeed, 9));

      /*if(direction = 1) { //down-left
        do setDirection(3); //up-right
      } else {
        if(direction = 2) { //down-right
          do setDirection(4); //up-left
        } else {
          if(direction = 3) { //up-right
            do setDirection(1); //down-left
          } else {
            if(direction = 4) { //up-left
              do setDirection(2); //down-right
            }
          }
        }
      }*/
    }

    return;
  }

  method boolean checkIfOutOfBounds(int x, int y) {
    var boolean outOfBounds;
    let outOfBounds = false;

    if (x < 0) {
      let outOfBounds = true;
      if(direction = 1) { //down-left
        do setDirection(2); //down-right
      } else {
        if(direction = 4) { //up-left
          do setDirection(3); //up-right
        }
      }
    }

    if (x + length > 512) {
      let outOfBounds = true;
      if(direction = 2) { //down-right
        do setDirection(1); //down-left
      } else {
        if(direction = 3) { //up-right
          do setDirection(4); //up-left
        }
      }
    }

    if (y < 0) {
      let outOfBounds = true;
      if(direction = 3) { //up-right
        do setDirection(2); //down-right
      } else {
        if(direction = 4) { //up-left
          do setDirection(1); //down-left
        }
      }
    }

    if (y + length > 256) {
      let outOfBounds = true;
      if(direction = 2) { //down-right
        do setDirection(3); //up-right
      } else {
        if(direction = 1) { //down-left
          do setDirection(4); //up-left
        }
      }
    }

    return outOfBounds;
  }

  method void refreshFrame(int location) {
    let memAddress = 16384+location;
    do Memory.poke(memAddress+0, 0);
    do Memory.poke(memAddress+32, 0);
    do Memory.poke(memAddress+64, 0);
    do Memory.poke(memAddress+96, 0);
    do Memory.poke(memAddress+128, 0);
    do Memory.poke(memAddress+160, 0);
    do Memory.poke(memAddress+192, 0);
    do Memory.poke(memAddress+224, 0);
    do Memory.poke(memAddress+256, 0);
    do Memory.poke(memAddress+288, 0);
    do Memory.poke(memAddress+320, 0);
    do Memory.poke(memAddress+352, 0);
    do Memory.poke(memAddress+384, 0);
    do Memory.poke(memAddress+416, 0);
    do Memory.poke(memAddress+448, 0);
    do Memory.poke(memAddress+480, 0);
    return;
  }

  method void draw(int location) {
    let memAddress = 16384+location;
    do Memory.poke(memAddress+0, 0);
    do Memory.poke(memAddress+32, 0);
    do Memory.poke(memAddress+64, 448);
    do Memory.poke(memAddress+96, 2032);
    do Memory.poke(memAddress+128, 4088);
    do Memory.poke(memAddress+160, 8060);
    do Memory.poke(memAddress+192, 7740);
    do Memory.poke(memAddress+224, 7196);
    do Memory.poke(memAddress+256, 7740);
    do Memory.poke(memAddress+288, 8060);
    do Memory.poke(memAddress+320, 4088);
    do Memory.poke(memAddress+352, 2032);
    do Memory.poke(memAddress+384, 448);
    do Memory.poke(memAddress+416, 0);
    do Memory.poke(memAddress+448, 0);
    do Memory.poke(memAddress+480, 0);
    return;
}

  function int modulus(int a, int b) {
    return a - (b * (a / b));
  }

}